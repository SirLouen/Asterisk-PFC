% -*-caso_de_uso_3.tex-*-
% Este fichero es parte de la plantilla LaTeX para
% la realización de Proyectos Final de Carrera, protejido
% bajo los términos de la licencia GFDL.
% Para más información, la licencia completa viene incluida en el
% fichero fdl-1.3.tex

\newpage

\color[rgb]{0,0,1}

\section{Nuevas Incorporaciones}

Poco tiempo después de incorporar el Centro de Llamadas para Almacén dentro de la empresa, el gerente Sr. Doe, vuelve a contactar con nosotros. Nos indica que el sistema ha prosperado y que el Mánager de Almacén ha conseguido controlar la situación sin mucha dificultad, próximamente contratarán a una persona más, y así modifiquemos un poco el sistema, porque se ven un poco desbordados dado que se les acumula el trabajo que ya previamente hacían con la nueva encomendación, aunque sus ventas estaban aumentando de forma bastante fuerte. Pero la llamada fue realmente para informarnos, que había contratado a una nueva persona, dentro del departamento de Marketing, ya que tenían intención de mejorar algunos aspectos a nivel tecnológicos dentro de la empresa, y montar un CRM para la gestión de la fuerza comercial dado que también estaba aumentando y tenía programado contratar dos vendedores más en los próximos días. Concertamos una cita con el nuevo empleado, llamado Pedro de los Palotes, unos días después de incorporarse.

La nueva figura, tenía conocimientos aceptables sobre el mundo del marketing, pero su principal manejo era las tecnologías de la información, y unos buenos conocimientos de informática en general. Durante la reunión que mantuvimos con el, nos comentó por encima alguna de las funciones que tenía que cumplir, y que tenían mucho que ver con nosotros, dado que necesitaba que introdujéramos algunas modificaciones en la central si fueran posibles. Además el Sr. Doe le dio carta blanca para ello, dado que tenía muy buenas referencias de él, y sabía bien lo que hacía. Lo que pudimos sacar fue:

\begin{enumerate}

\item Le habían ofrecido la oportunidad de montar en un servidor independiente para incorporar un sistema de CRM
\item Querían que controlara los gastos y la facturación de los conceptos de telefonía dado que habían observado ciertos usos indebidos, pero no sabían a quien achacar esta responsabilidad
\item Necesitaban que el Sr. de los Palotes, tuviera más autocontrol sobre Asterisk, aunque no tenía conocimientos de como funcionaba internamente, el sistema, para poder ser algo más autónomos dado los cambios que se avecinaban.
\item Finalmente, también el Mánager Comercial, el cual tenía dificultades a veces para establecer la comunicación con sus proveedores cuando necesitaban tener conversaciones entre más de dos usuarios simultáneamente, le había encomendado ver si era posible alguna pequeña mejora para poder solucionar esto.

\end{enumerate}

Tras poner cada una de las tareas encima de la mesa, hicimos un primer planteamiento para dividir las nuevas encomendaciones en diferentes secuencias que iríamos incorporando en nuestra máquina Asterisk progresivamente para ir probando su funcionalidad con Pedro. Le pareció bien, y nos pusimos manos a la obra.

\newpage

\color[rgb]{0,0,0}


\subsection{Generación Automática de Eventos}
Antes de nada, creamos una nueva extensión para el Sr. Pedro de los Palotes, dentro del grupo de Marketing, la número 54, en el fichero sip.conf, y por otro lado, le habilitamos dicha extensión en el Plan de Marcación extensions.conf.

En primera instancia, hicimos un breve análisis de sus pretensiones de montar un servidor CRM propio, dado el mantenimiento y dedicación que esto llevaba, queríamos averiguar un poco su planteamiento y de que forma quería que nuestro sistema Asterisk trabajara con su sistema CRM. En primer lugar, no observamos que tuviera ningún conocimiento acerca de sistemas de motorización de sistemas informáticos, dado que en realidad aun sus buenos conocimientos del tema, realmente su función no era la mantener el sistema. 

Hasta la fecha según nos comento, en su anterior empresa, había estado trabajando con un CRM llamado vTiger CRM \cite{website:vtiger}, lo cual nos agradó bastante dado que conocíamos su buena integración con Asterisk a traves del Asterisk Manager Interface. Pero en su caso, solo había utilizado vTiger en un servidor externalizado online, y todas las tareas de mantenimiento se las llevaba una empresa de hosting web, y el solo se encargaba de administrar y gestionar el sistema CRM. Según había oído, era posible con los CTI \cite{website:ctiwikipedia} de algunas PBX, era posible que directamente desde la interfaz web de vTiger, los usuarios pudieran cursar llamadas, y otras tantas funcionalidades.

Le informamos que esto era posible, siempre y cuando el servidor para su servicio, estuviera dentro de la misma red local, dado que ``abrir'' a Internet el CTI de Asterisk suponía serias implicaciones en la seguridad del sistema de las cuales no podíamos hacernos totalmente responsables. Le pusimos en contacto con una empresa colaboradora nuestra, "Cadiz Computers" para que le facilitarán el trabajo de montaje, mantenimiento y administración del servidor CRM, pero de momento para que pudieran empezar a trabajar, le informamos de una funcionalidad de Asterisk que le serviría para poder establecer un mínimo de motorización sobre el estado de su servidor web, donde se contenía la aplicación vTiger, que realmente estaba basada en el lenguaje de programación PHP.

Para ello en primer lugar, considerando que el servidor web ya esta funcionando con su aplicación CRM en marcha, instalamos telnet en nuestro servidor Asterisk:

\begin{lstlisting}[style=consola]
sudo aptitude install telnet
\end{lstlisting}

Y creamos un script bash que va a cumplir las función de motorización en un nivel muy básico, pero haciendo uso de nuestro sistema Asterisk como estaba previsto:

\lstinputlisting[title={./apache\_monitor.sh},style=bash]{../scripts/apache_monitor.sh}

Debemos darle privilegios de escritura:

\begin{lstlisting}[style=consola]
chmod +x apache_monitor.sh
\end{lstlisting}

Y ahora tenemos que crear el fichero que generara un Llamada Automatica \footnote{WikiAsterisk Generación Automática de Llamadas, \\ http://wikiasterisk.com/index.php?title=GeneraciC3B3n\_Autom\%C3A1tica\_de\_llamadas}, que llamaremos \textbf{apache\_warning.call}:

\lstinputlisting[title={./apache\_warning.call},style=bash]{../scripts/apache_warning.call}

Finalmente añadimos una linea en el fichero del proceso Cron, crontab, para que comprueba cada minuto, el estado de nuestro servidor gracias al script recién creado:

\begin{lstlisting}[style=bash,title={/etc/crontab}]
*/1 * * * * sh /home/asterisk/repositorio/scripts/apache_monitor.sh
\end{lstlisting}

En el momento que el servidor web deje de atender a las peticiones entrantes por el puerto 80, el Sr. de los Palotes recibirá una llamada de emergencia en su extensión personal, cuyo CallerID será Emergencias CRM <111>, hasta que se resuelva el problema.

\subsection{Comprobación: Generación Automática de Eventos}

En el momento que paremos el servidor web en el servidor donde esta asociado el script deberían empezar a recibirse llamadas en la extensión 54 si la tenemos configurada en algun télefono.

Para parar el servidor web, suponiendo por ejemplo que estemos utilizando apache en el servidor remoto, deberíamos ejecutar en el mismo:

\begin{lstlisting}[style=consola]
# sudo service apache2 stop
\end{lstlisting}

En cuestión de un minuto máximo recibiremos la llamada. Podemos comprobar también en esa llamada que el Identificador de llamada hace referencia a ``Emergencias Servidor'' (Figura \ref{servidor_caido}) Además deberíamos escuchar al responder una reproducción indicando la alerta.

\figura{servidor_caido.png}{scale=1}{Llamada Entrante de alerta}{servidor_caido}{!ht}

\newpage

\subsection{Probando nuestro CTI, Asterisk Manager Interface}

Ahora vamos a montar el sistema para que el CRM vTiger pueda integrarse con nuestra máquina Asterisk. Tan pronto este preparado le daremos las credenciales al nuevo responsable IT para que pudiera poner en marcha lo necesario.

Cuando hicimos la primera instalación de Asternic Stats para la gestión de Colas ya tuvimos una pequeña aproximación al Manager de Asterisk, pero ahora se vería un poco más en detalle dados algunos problemas que surgieron durante la integración del sistema vTiger con nuestra máquina.

En primer lugar, necesitábamos definir el fichero manager.conf, encargado de toda la gestión de AMI y adaptarlo un poco más para diferenciar el proceso específico de Asternic, de la integración de vTiger, especialmente por si tenemos la necesidad de tener controlados los eventuales problemas posibles a nivel de depuración.

Para ello editamos el ficheros con la siguiente información:

\lstinputlisting[title={/etc/asterisk/manager.conf},style=bash]{../conf/manager.conf}

Viendo este fichero en detalle podemos observar por un lado, que hemos especificado un usuario concreto para Asternic Stats, y le hemos retirado todos los privilegios de escritura, dado que al ser solo una aplicación de monitoreo no le va a hacer falta. Podríamos entender por el contexto de la aplicación que tipo de permisos de lectura le harían falta (seguramente los parámetros \textbf{agent} y \textbf{call} serían suficientes).

Y por otro lado, ya hemos definido un usuario especifico para hacer la integración con vTiger, tampoco tenemos muy claro que permisos le harían falta, en este caso hemos definido la dirección IP local del servidor al que va a hacer referencia, para al menos establecer un punto más de seguridad y control al respecto.

El resto de los parámetros son los necesarios para el buen funcionamiento como podemos ver en detalle en el aparto de configuración del AMI \footnote{Configuración AMI, http://wikiasterisk.com/index.php?title=AMI} dentro de la WikiAsterisk.

A partir de aquí nos ponemos en contacto con Pedro para intentar coordinar el funcionamiento del sistema y ver si realiza la operación de manera adecuada. Ya hicimos otras integraciones de vTiger con nuestro sistema Asterisk en el pasado, pero dadas las constantes actualizaciones del CRM queríamos asegurarnos que todo iba bien.

En primer lugar, hicimos la parte de configuración más clásica del sistema para el usuario del Mánager Comercial que sería uno de los principales actores dentro de esta aplicación, el Sr. Douglas, segun vemos en la siguiente figura \ref{vtiger_config}

\figura{vtiger_config.png}{scale=1}{Configuración de la extensión en Vtiger}{vtiger_config}{!ht}

Por otro lado era necesario cubrir los aspectos concretos de configuración del sistema Vtiger para interconectar con nuestra interfaz AMI con las credenciales recien configuradas, reflejado en la Figura \ref{vtiger_config_ami}.

\figura{vtiger_config_ami.png}{scale=1}{Configuración de los parámetros AMI en Vtiger}{vtiger_config_ami}{!ht}

Con esto supuestamente le indicamos al Sr. de los Palotes que probara a realizar las operaciones que conocía para trabajar con el sistema vTiger, pero comprobamos que no funcionaba nada. Buscando en la web, pudimos observar que vTiger requería de algunas modificaciones a nivel interno para su correcta integración con nuestro Plan de Marcación, así que revisando la página oficial de configuración \cite{website:vtigerpbx} nos dímos cuenta que era fundamental modificar un archivo propio del PBXManager (al parecer un módulo encargado de realizar toda esta gestión de interpretación de Mánager de Asterisk), y las modificaciones pertinentes las hicimos según podemos ver a continuación:

\begin{lstlisting}[style=php,title={./www/vtigercrm/modules/PBXManager/utils/AsteriskClass.php}]
switch($typeCalled){
 case "SIP":
  $context = "extensiones";
  break;
 case "PSTN":
  $context = "extensiones";//"outbound-dialing";
  break;
 default:
  $context = "extensiones";
}
\end{lstlisting}

Con esto pudimos hacer que todas las llamadas salientes desde vTiger, se encaminaran a nuestro contexto de ``Extensiones'' principal, con suponía observar. Al parecer era posible realizar personalizaciones dentro de vTiger en función del tipo de teléfono al que deseáramos llamar (si fuera un teléfono tipo SIP, o por la linea de teléfono convencional (PSTN), pero como en nuestro caso, no hacemos esta diferenciación dentro de nuestro DialPlan, preferimos optar por utilizar el mismo contexto del DialPlan por defecto.

Y por último estuvimos comprobando, si llamando a la extensión 21 que acabábamos de configurar para el Sr. Douglas, se recibía dentro del sistema vTiger un mensaje pop-up indicando información referente al llamante, para comprobar que no era así. Al parecer las últimas versiones de vTiger provocaban serios fallos en la integración con instalaciones de Asterisk versiones 1.8 o superiores, de hecho como vimos en la Figura \ref{vtiger_config_ami} en la versión solo podíamos indicar 1.6 como máximo. 

Así que tuvimos que realizar ya algunas modificaciones más intensas de codigo, dentro del fichero que manejaba esta habilidad de gestionar las llamadas entrantes.

La incidencia más significativa que encontramos fue, dentro de la función \textbf{asterisk\_handleResponse2} nos dimos cuenta, que no solo el condicional tampoco valía, la sintaxis de uno de los parámetros llamado AppData del comando NewExten, habia cambiado significativamente, por esto adaptamos un poco el código PHP para que sirviera para esta nueva aplicación:

\begin{lstlisting}[style=php,title={./www/vtigercrm/cron/modules/PBXManager/AsteriskClient.php}]

// if($mainresponse['Event'] == 'Newexten' && 
//(strstr($appdata, "__DIALED_NUMBER") || 
//strstr($appdata, "EXTTOCALL")))
if($mainresponse['Event'] == 'Newexten' && 
\$mainresponse['Application'] == 'Dial')

// $splits = explode('=', $appdata);
// $extension = $splits[1];
$splits = explode('/', $appdata); 
$longextension = $splits[1];
$splits = explode(',',$longextension);
$extension = $splits[0];

\end{lstlisting}

Esto ocurría porque concretamente, utilizando la función PHP ``explode'' para segmentar una cadena de texto, la cadena dentro Event Newexten, correspondiente al parámetro AppData, tenía una estructura del tipo, SIP/10,30, siendo SIP/10 el dispositivo SIP al que apuntaría la aplicación para mostrar el mensaje emergiente, y 30, los segundos antes del "timeout". Con esto, retiraría todos estos argumentos y nos quedaríamos exclusivamente con el "10" para este ejemplo que podría corresponderse con la extensión asignada a un usuario en el sistema vTiger.

Y con estos dos cambios el sistema ya funcionaba a la perfección, y dimos por integrado vTiger con nuestra versión de Asterisk.

\subsection{Comprobación: Probando nuestro CTI, Asterisk Manager Interface}

Esta parte esta principalmente orientada al uso de vTiger que se realizo en el servidor externo, habría que considerar que el correcto desarrollo de un sistema externo como vTiger realmente no esta directamente relacionado con la idea de este proyecto, pero provee de un ejemplo interesante dentro del concepto de las Comunicaciones Unificadas. 

Teniendo presentes algunos conceptos básicos de instalación del mismo que no se han cubierto dentro de este proyecto, y haciendo las pequeñas modificaciones necesarias podríamos conseguir los resultados.

Igualmente hemos provisto de una instalación de vTiger de ejemplo con las credenciales \textbf{hdouglas}, y la contraseña \textbf{asterisk} haciendo referencia al Jefe Comercial del Caso de Estudio.

A continuación en la Figura \ref{llamandaentrante} y la Figura \ref{llamandasaliente} podemos comprobar los mensajes emergientes, para visualizar el resultado de una correcta puesta en marcha.

\figura{vtiger_incoming.png}{scale=1}{Llamada Entrante en Vtiger}{llamandaentrante}{!ht}

\figura{vtiger_outgoing.png}{scale=1}{Llamada Saliente en Vtiger}{llamandasaliente}{!ht}

\newpage

\subsection{Devolviendo el Control al Cliente}

Atendiendo a la petición de nuestro cliente para poder ofrecerle la posibilidad de ser más autónomo en la gestión de sus propias extensiones, con la voluntad de darlas de alta y baja por cuenta propia, era fundamental incorporar en nuestro sistema Asterisk un nuevo elemento, el sistema Asterisk RealTime, equivalente a ``trasvasar'' todo el sistema de configuración interno de los ficheros de texto plano, estáticos por naturaleza, a un sistema más dinámico, basado en Bases de Datos, cuya interpretación de las mismas cara a la configuración del sistema, se haría en tiempo real. Esta funcionalidad que ofrece Asterisk, es muy práctica, si tenemos la intención de querer brindar algún tipo de interfaz, por ejemplo, en entorno web, para modificar los parámetros de una manera mucho más cómoda y confiable.

Aunque es cierto que existen interfaces web ya creadas a medida para Asterisk, que no requieren de Bases de datos, ya que también permiten interpretar los ficheros de texto plano directamente, y estos adaptarlos a la misma, para mostrar su contenido y poder a su vez ser editado y reintroducido en los ficheros de configuración, el nivel de control que brindan al usuario que las utiliza es prácticamente total, y esto significa que un usuario inexperto podría provocar un problema en el sistema de forma casi involuntaria. 

Además, por la propia definición de estas interfaces, su sistema radica, primero, en una lectura linea por linea del fichero de configuración, para interpretar su contenido, plasmarlo en la interfaz cara al usuario, y luego en caso de edición por parte de este, volver a reescribir literalmente ese fichero de texto de forma automáticamente, en el formato más conveniente por el sistema interfaz. Esto supone que la introducción y configuración de nuevos parámetros por un usuario más avanzado puede suponer una interferencia e incluso una inconveniencia, aunque dado el caso, existe la posibilidad de adaptar ficheros de configuración a medida en comunión a los ``automáticos'' generados por estas interfaces, que en un peor de los casos, incluso podrían provocar una redundancia en la funcionalidad (y poder derivar en errores de difícil detección)

En general este tipo de interfaces, solo son utilizadas por usuarios noveles del sistema Asterisk y el nivel de personificación de la máquina esta limitada realmente al número de posibilidades que ofrezcan estas interfaces por defecto independientemente de las posibilidades de ``personalización'' que puedan llegar a aportar. Algunos de los contras que he comentado, suelen ser las críticas que alegan, la mayor parte de los usuarios más experimentados en la comunidad Asterisk.

En consecuencia a esto, la idea para poder ofrecer autonomía sería la siguiente:

\begin{enumerate}

\item {Vamos a ofrecer la posibilidad de configurar pares SIP a voluntad del usuario, como extensiones posibles dentro del rango 10 al 59}
\item {Tendremos que pasar la configuración del sistema SIP a Asterisk RealTime realizando las configuraciones en el sistema oportunas}
\item {Tendremos que modificar el plan de marcación para ofrecer el número máximo de opciones que contemplen el rango limitado de creación de extensiones que vamos a ofrecer}
\item {Finalmente crearemos una aplicación en PHP para la creación y eliminación de extensiones SIP de forma dinámica}

\end{enumerate}

Considerando esto, en primer lugar, tocaría realizar la configuración de los ficheros correspondientes, para poder establecer un puente entre Asterisk, y nuestra base de datos SQL donde alojaremos la configuración de los pares SIP (sippeers). Para ello utilizaremos el driver ODBC de nuestro sistema Linux que asociaremos con el recurso ODBC que ofrece Asterisk.

El primer fichero de configuración sería extconfig.conf como vemos a continuación:

\lstinputlisting[title={/etc/asterisk/extconfig.conf},style=bash]{../conf/extconfig.conf.1}

Un fichero muy sencillo, indicamos que el módulo que vamos a convertir es el encargado de gestionar los pares del canal SIP, utilizando el driver ODBC, para enlazarlo con el recurso ODBC de Asterisk en el contexto \textbf{asterisk\_odbc}, y que la tabla se llamará \textbf{pares\_sip}.

Ahora el segundo fichero, sería res\_odbc.conf:

\lstinputlisting[title={/etc/asterisk/res\_odbc.conf},style=bash]{../conf/res_odbc.conf}

En este caso también una estructura muy sencilla. Especificamos que el DSN del Driver ODBC será llamado asterisk, y queremos que conecte utilizando unas credenciales específicas que vamos a añadir en nuestra base de datos MySQL del paquete LAMP que instalamos al principio

Ahora vamos a modificar el fichero sip.conf donde se encuentran los pares en formato ``estático'', para que se adapte a la nueva configuración en formato Asterisk Realtime "dinámico". Nos quedaría tan simple de la siguiente forma:

\lstinputlisting[title={/etc/asterisk/sip.conf},style=bash]{../conf/sip.conf.2}

Con estos pasos tan sencillos, ya tenemos la parte Asterisk funcionando.

Ahora nos toca preparar el Driver ODBC a nivel Linux. Considerando que estamos trabajando con Ubuntu, es importante, dado que las librerías ODBC para MySQL se ubican en directorios diferentes que en otras distribuciones como RedHat o CentOS. Por ello necesitamos especificar la ruta exacta utilizando el fichero de configuración ubicado en el directorio /etc/, llamado \textbf{odbcinst.ini}:

\lstinputlisting[title={/etc/odbcinst.ini},style=bash]{../conf/odbcinst.ini}

Es importante considerar que tenemos los paquetes unixodbc y libmyodbc, para el correcto funcionamiento:

\begin{lstlisting}[style=consola]
sudo aptitude install unixodbc libmyodbc
\end{lstlisting}

Y finalmente configuramos el DSN en el fichero odbc.ini:

\lstinputlisting[title={/etc/odbc.ini},style=bash]{../conf/odbc.ini}

En este caso, dado que las credenciales las especificamos en el recurso ODBC, vamos a realizar la conexión utilizando un socket específico para mysql que en Ubuntu server se encuentra en el directorio especificado dentro de la configuración de este fichero.

Ahora, necesitamos prepara la Base de Datos SQL, utilizando mySQL, concretamente la interfaz grafica phpMySQL basada en el lenguaje de programación PHP. Pero eventualmente para las primeras tareas básicas de configuración vamos a utilizar la interfaz por linea de comandos que incorpora MySQL en su instalación.

En primer lugar vamos a crear la base de datos \textbf{asterisk}, especifica para el cometido que estamos buscando:

\begin{lstlisting}[style=consola]
mysqladmin -u root -p create asterisk
\end{lstlisting}

GRANT ALL PRIVILEGES ON `asterisk` . * TO 'asterisk'@'localhost';


Ahora vamos a crear un usuario llamado asterisk, para que pueda operar exclusivamente en esta base de datos:

\lstinputlisting[title={usuarioasterisk.sql},style=bash]{../scripts/usuarioasterisk.sql}

Y lo introducimos en nuestro sistema:

\begin{lstlisting}[style=consola]
mysql -u root -p < usuarioasterisk.sql
\end{lstlisting}

Ahora finalmente vamos a crear la tabla pares\_sip dentro de la base de datos llamada asterisk, para ello creamos un fichero y lo cargamos:

\lstinputlisting[title={pares\_sip.sql},style=sql]{../scripts/pares_sip.sql}

\begin{lstlisting}[style=consola]
mysql -u root -p asterisk < pares_sip.sql
\end{lstlisting}

Notese que existe un campo, que no es creado por defecto en este tipo de tabla de sippeers. Estamos hablando del campo \textbf{useradmin}, que nos va a servir a posteriori, cuando diseñemos una pequeña aplicación para poder ofrecer un entorno visual de edición de usuarios de esta tabla, para configurar el sistema de pares al completo. Así que le damos este privilegio (1) a la extensión 10 y 54 que serán en principio mientras no se diga lo contrario, los dos ``administradores'' del sistema.

Con toda la estructura creada, solo nos queda empezar a insertar los pares con los que veniamos trabajando anteriormente dentro de la tabla y comprobar que todo funciona correctamente. Para ello creamos otro fichero sql donde insertamos toda la información al respecto, en este caso vamos a utilizar 3 pares de ejemplo, el resto los haremos utilizando la herramienta phpMyAdmin:

\lstinputlisting[title={ejemplo\_pares\_sip.sql},style=sql]{../scripts/ejemplo_pares_sip.sql}

\begin{lstlisting}[style=consola]
mysql -u root -p asterisk < ejemplo_pares_sip.sql
\end{lstlisting}

Ahora es el momento de diseñar una aplicación en PHP muy sencillo para poder llevar una pequeña gestión de los pares SIP de forma descentralizada por parte de nuestro usuario. La idea sería, basandonos en la tabla recién creada ``pares\_sip'', poder considerarla como un sistema de acceso de usuarios para ciertos usuarios, y ademas, será la tabla que realmente pretendemos que nuestros usuarios de UCA Autos puedan editar a voluntad. Este script de momento es una primera instancia para poder ofrecer lo que nuestros usuarios necesitan, pero quizá en un futuro sería mejorable, optimizando la seguridad de acceso al mismo, ya que con técnicas poco ortodoxas como la Inyección de código SQL podrían acceder al mismo sin grandes dificultades.

El script se irá describiendo a continuación \footnote{Montando un Sistema Asterisk Autonomo I, \\ http://10000horas.com/asterisk/2011/12/08/montando-un-sistema-asterisk-autonomo-i}, primero conectamos a la base de datos \textbf{asterisk}:

\begin{lstlisting}[style=php,title={./www/usuarios.php}]

 <?php

// Conexion a la base de Datos

$base = "asterisk";
$host = "localhost";
$user = "asterisk";
$password = "asterisk";
$conexion = mysql\_connect($host,$user,$password);
\$result = mysql\_select\_db($base,$conexion) 
or die ("Error en la Conexion a BD");

\end{lstlisting}

A continuación, registramos una sesión con una Cookie, y hacemos una consulta condicional, a la base de datos en caso que no estenmos logeados (es decir, en nuestra Cookie, no aparezca la variable de sesión \textbf{login} que indica que estamos registrados), y con esta consulta, comprobamos si el usuario esta registrado o no, en caso que lo este, registramos las variables de sesión incluyendo la variable \textbf{login}, para que no nos vuelva a solicitar inicio de sesión en adelante.

Como vemos, en caso que no hubiesemos accedido al sistema, nos aparecería un pequeño formulario pidiendo las credenciales, que al rellenarlo, lanzaría las credenciales como variables para una consulta SQL contra nuestra Base de Datos:

\begin{lstlisting}[style=php,title={./www/usuarios.php}]

session_start();

// Si no estamos logeados

if (!$_SESSION['login'])
{
 if(isset($_POST['loginsubmit']))
 {
 $usuario = $_POST['usuario'];
 $password = $_POST['password'];

 if((!$usuario) || (!$password))
 {
 echo "Error 1<br>";
 exit();
 }
 $password = $usuario.":asterisk:".$password;
 $password = md5($password);
 $query = mysql_query("SELECT * FROM pares_sip WHERE 
 name='$usuario' AND md5secret = '$password' AND useradmin = '1'");
 if (mysql_num_rows($query) > 0)
 {
 session_register('login');
 $_SESSION['login'] = '1';
 }
 else
 echo "Error 2<br><br>";

 echo "<a href='usuarios.php'>Home</a>";
 }
 else
 {
 echo "<form method='post' action='?'>";
 echo "Usuario: <input name='usuario' type='text'><br>";
 echo "Contrase&ntilde;a: <input name='password' type='password'><br>";
 echo "<input type='submit' name='loginsubmit'>";
 echo "</form>";
 }

}

\end{lstlisting}

En caso que ya estemos logeados, nos ofrece un pequeño menu por si queremos avanzar hacia el formulario para insertar o destruir registros SIP o si queremos salir, en el segundo caso, destruiría la Cookie con la sesión y nos daría la opción a volver a la pantalla de inicio de la aplicación donde nos vuelve a solicitar las credenciales de acceso.

A partir de aquí, considerando, que hayamos lanzado el formulario que veremos al final de la descripción de esta aplicación, en caso que hayamos rellenado el formulario de insertar un registro, recibiríamos los parámetros, y crearíamos una consulta SQL con los mismos a medida, para insertarla en nuestra base de datos. Con esto quedaría registrado nuestro usuario y podríamos volver a nuestro panel principal.

\begin{lstlisting}[style=php,title={./www/usuarios.php}]

// Si ya estamos logeados

else
{
 // Salida del Sistema
 if(isset($_REQUEST['exit']))
 {
 session_destroy();

 if(!session_is_registered('login'))
 echo "<a href='usuarios.php'>Home</a>";

 }
 // Insercion de un nuevo Registro
 elseif(isset($_POST['insertsubmit']))
 {
 $sipuser = $_POST['sipuser'];
 $sippass = $_POST['sippass'];
 $contexto = $_POST['contexto'];
 $sippass = $sipuser.":asterisk:".$sippass;
 $sippass = md5($sippass);
 $buzon = $sipuser."@default";
 $query = mysql_query("INSERT INTO pares_sip 
 (`name`, `host`, `nat`, `type`, `context`, `md5secret`, 
 `qualify`, `disallow`, `allow`, `port`, `regseconds`, 
 `lastms`, `username`, `defaultuser`, `mailbox`)
 VALUES ('$sipuser', 'dynamic', 'no', 'friend', '$contexto', 
 '$sippass', 'yes', 'all', 'alaw;gsm;ulaw',
 '0','0', '0', '', '', '$buzon')");

 echo "<a href='usuarios.php'>Home</a><br>";
 echo "<a href='usuarios.php?exit'>Exit</a>";
 }

\end{lstlisting}

La segunda posibilidad, es que hayamos optado por pulsar el botón del formulario principal para borrar un registro SIP. En este caso, haría el borrado lanzando la consulta SQL correspondiente, asociándolo al identificador concreto del Par SIP que hayamos decidido eliminar:

\begin{lstlisting}[style=php,title={./www/usuarios.php}]

 // Borrado de un Registro
 elseif(isset($_POST['deletesubmit']))
 {
 $sipid = $_POST['sipid'];
 $query = mysql_query("DELETE FROM pares_sip WHERE id = '\$sipid'");

 echo "<a href='usuarios.php'>Home</a><br>";
 echo "<a href='usuarios.php?exit'>Exit</a>";
 }

\end{lstlisting}

Finalmente, están los dos posibles formularios, tanto el de inserción como el de borrado, los cuales recogen las variables para pasárselas a las consultas anteriormente explicadas:

\begin{lstlisting}[style=php,title={./www/usuarios.php}]

 // Formularios de Insercion y Borrado
 else
 {
 echo "Insertar Registro:<br>";
 echo "<p><form method='post' action='?'>";

 echo "Usuario: <input name='sipuser' type='text'><br>";
 echo "Contrase&ntilde;a: <input name='sippass' type='password'><br>";
 echo "Tipo: <select name='contexto'>";
 echo "<option value='extensiones'>Resto</option>";
 echo "<option value='manager'>Manager</option>";
 echo "<option value='gerencia'>Gerencia</option>";
 echo "</select><br>";
 echo "<input type='submit' name='insertsubmit' value='Insertar'>";
 echo "</form></p>";

 echo "<table border='1'>";
 echo "<tr><td colspan ='2' align='center'>SIP Peers Activos</td></tr>";
 echo "<tr><td>Usuario</td><td>Borrar</td></tr>";

 $query = mysql_query("SELECT * FROM pares_sip WHERE type = 'friend'");
 $rows = mysql_num_rows($query);
 for ($i=0;$i<$rows;$i++)
 {
 $sippeersarray = mysql_fetch_array($query);
 $sipuser = $sippeersarray['name'];
 $sipid = $sippeersarray['id'];

 echo "<tr>";
 echo "<td>".$sipuser."</td>";
 echo "<td>";
 echo "<form method='post' action='?'>";
 echo "<input type=hidden name='sipid' value='\$sipid'>";
 echo "<input type=submit name='deletesubmit' value='Borrar'>";
 echo "</form>";
 echo "</td>";
 echo "</tr>";

 }
 echo "</table>";
 echo "<a href='usuarios.php?exit'>Exit</a>";

 }
}
?>

\end{lstlisting}

Con esta aplicación somos capaces de crear todas las extensiones que creamos antes, exactamente con la misma configuración, en una cuestión de 1 minuto, siendo un ejemplo de escalabilidad y flexibilidad.

Finalmente hemos de modificar el Plan de Marcación para que acepte todo tipo de extensiones dentro del rango que establecimos (de la extensión 10 a la extensión 59 hasta nuevo aviso). Para ello realizamos la siguiente pequeña modificación:

\begin{lstlisting}[style=bash,title={/etc/asterisk/extensions.conf}]

; Todas las Extensiones para Asterisk RealTime
exten => _[1-5]X,1,Macro(telefonos)
exten => _9[1-5]X,1,Macro(buzon)

\end{lstlisting}

Y con esto ya quedaría terminada por completo esta parte del trabajo.

\subsection{Comprobación: Devolviendo el Control al Cliente}

En primera instancia debemos acceder al servidor web, a la url http://pfc-asterisk.local/usuarios.php para comprobar que podemos acceder a la interfaz de creación de usuarios, acceder con nuestras credenciales (en el ejemplo las de la extensión 54, contraseña 1234), y probar a crear y borrar usuarios a voluntad.

Una vez hayamos creado un usuario SIP considerando el rango permitido que hablábamos antes (del 10 al 59), podemos crear una extensión que no estuviera antes, configurarla en un dispositivo SIP, y probar a llamar al mismo para comprobar que recibe la llamada correctamente.

El mismo efecto, para comprobar que el sistema de buzón de voz funciona, teniendo presente, que esto tendríamos que configurarlo de momento, manualmente dado que el sistema de Buzones de Voz, no se ha migrado al sistema RealTime, práctica que quizá también resultaría interesante para obtener una independencia integral.

\newpage

\subsection{Análisis de Asterisk con Lupa}

Continuando con la serie de trabajos encomendados por el señor Pedro, era el momento de hacer frente a la gestión y el control del registro de llamadas, dado que según nos comento nuestro cliente, había observado en la factura de teléfono que se estaban haciendo usos desmedidos del mismo, pero no podía controlar bien, quien y porque, estaba incurriendo en este gasto desmesurado. Quiza fuese simplemente porque se sabía que hasta el momento no existía un mecanismo de control eficiente, y era raro tener este tipo de controles para las PYME del sector, en las PBX convencionales dado que suponían unos sistemas de licenciamiento bastante costosos.

En este caso, sabemos que Asterisk ofrece un registro de llamadas que podemos extraer desde diversas fuentes, pasando por ficheros de texto hasta las bases de datos de diferentes tipos, siguiendo un estilo muy parecido de almacenamiento, al que describimos anteriormente cuando hicimos el trasvase de configuración del módulo SIP al modelo de Tiempo Real (Asterisk Realtime).

En primer lugar vamos a configurar el sistema de almacenamiento del Registro de Llamadas (CDR), en la base de Datos que creamos anteriormente para nuestro sistema RealTime, solo que vamos a tener que crear una tabla nueva específica para almacenar todos los registros CDR.

Por ello, la primera parte sería la de configurar el fichero cdr\_adaptive\_odbc.conf y dotarlo de una estructura genérica para que conecte a nuestro anterior ``conector'' para el registro DSN del Driver ODBC que especificamos en la anterior sección (el llamado "asterisk\_odbc" de res\_odbc.conf). Con esto configuramos el fichero cdr\_adaptive\_odbc.conf de la siguiente forma:

\lstinputlisting[title={/etc/asterisk(cdr\_adaptive\_odbc.conf},style=bash]{../conf/cdr_adaptive_odbc.conf}

En segundo lugar, vamos a crear la tabla dentro de nuestra anteriormente creada base de datos Asterisk, con la siguiente estructura:

\lstinputlisting[title={sistemacdr.sql},style=sql]{../scripts/sistemacdr.sql}

Y cargamos la tabla dentro de nuestra base de datos ``asterisk'':

\begin{lstlisting}[style=consola]
mysql -u root -p asterisk < sistemacdr.sql
\end{lstlisting}

Con esto ya tendríamos el sistema CDR mandando registros autómaticamente.

Por otro lado, necesitaríamos proveer de algún tipo de interfaz, para que nuestro cliente, pudiera observar fácilmente lo que tiene intención (en este caso, controlar el mal uso de las lineas telefónicas y detectar los abusos por parte del personal). Para ello realizariamos la instalación de CDR-Stats como entorno web \footnote{CDR-Stats en WikiAsterisk, http://wikiasterisk.com/index.php?title=CDR-Stats} \cite{website:cdrstats}, según viene perfectamente descrito en la WikiAsterisk.

La instalación de este sistema, habria que considerar que ha ido bastante rápido, debido a que la preparación del sistema Asterisk Realtime, dio lugar a que las bases ya estuvieran sentadas, para la implementación de todos tipo de servicios que involucrarán la interrelación entre nuestra máquina Asterisk, y un sistema de Bases de Datos.

\subsection{Comprobación: Análisis de Asterisk con Lupa}

En primer lugar, tenemos que intentar acceder al sistema CDR-Stats desde la URL \\ http://pfc-asterisk.local/cdr-stats y comprobar que no hay ningun problema al menos en el acceso aunque pueda estar todo sin datos.

Para comprobar que esto funciona correctamente, en primer lugar tenemos que realizar múltiples llamadas aleatorias. Luego accediendo al sistema CDR-Stats nuevo deberían aparecer las llamadas prácticamente de inmediato

En la Figura \ref{cdrstats_grafico} y la Figura \ref{cdrstats_barras} mostramos las posibilidades que ofrecerá para el Sr. De los Palotes la Interfaz que acabamos de preparar para el manejo de todo el Detalle de Llamadas según hubiera pretendido. Dado que la instalación todavía es muy prematura sin uso ninguno, solo se ve como quedarían los ejemplos, pero sin suficiente información para que resulten lo suficientemente esclarecedores:

\figura{cdrstats_grafico.png}{scale=1}{Gráfico Circular de Llamadas Totales}{cdrstats_grafico}{!ht}

\figura{cdrstats_barras.png}{scale=1}{Histograma de Llamadas por días}{cdrstats_barras}{!ht}

Es importante considerar que si las llamadas no aparecen, podríamos comprobar si el sistema CDR esta en funcionamiento. Para ello podemos ejecutar la orden en la CLI:
\begin{lstlisting}[style=consola]

CLI> cdr show status

Call Detail Record (CDR) settings
----------------------------------
  Logging:                    Enabled
  Mode:                       Simple
  Log unanswered calls:       No

* Registered Backends
  -------------------
    Adaptive ODBC
    cdr-custom
		
\end{lstlisting}

\newpage

\subsection{Conferencias Corporativas}

Como último trabajo, nos tocaría introducir el sistema de Conferencing que incorpora Asterisk entre sus módulos generales, llamado MeetMe. También existe la opción de utilizar ConfBridge que es la nueva evolución del sistema, pero para este caso resulta suficiente el primero, y además integraremos una nueva interfaz web muy práctica, que seguirá en la linea de las anteriores configuraciones, aprovechando además la posibilidad de ofrecer configuraciones del sistema MeetMe en tiempo real (con Asterisk RealTime).

Nuestra intención dado el potencial que nos ofrece el sistema, es crear por un lado, una sala de conferencias estática, para uso del Jefe de Ventas, y luego un sistema general de salas de conferencia dínamico que ofreceremos al Sr. Pedro, para que pudiera crear futuras salas de conferencia a voluntad y ofrecerselas al resto de los empleados.

Para ello, vamos a asociar cada uno de los sistemas, a un número Direct Dial-In (DDI) cada una, y así podrán accederse a las mismas en cualquier momento. Solicitamos los respectivos números a nuestro operador UCA Telecom, y los asociamos al Plan de Marcación:

\begin{lstlisting}[style=bash,title={/etc/asterisk/extensions.conf}]

exten => 956001171,1,Goto(especiales,102,1)
exten => 956001172,1,Goto(especiales,103,1)

\end{lstlisting}

En este caso, el 956001171, sería para el sistema general de salas de conferencia, y el 956001172, para la sala de conferencias especifica para el Jefe de Ventas.

Ahora, en primer lugar vamos a crear la sala de Conferencias sencilla, basándonos en la Aplicación Meetme, y la asociaremos a un número Direct Dial-In (DDI) para su correspondiente acceso desde el exterior, para los posibles proveedores, o clientes, según nos comentaba nuestro cliente.

Para ello, vamos a configurar por un lado el fichero meetme.conf, con los parámetros suficientes para conseguir este resultado, según podemos ver a continuación:

\lstinputlisting[title={/etc/asterisk/meetme.conf},style=bash]{../conf/meetme.conf}

En este caso, hemos definido, una única sala, la número 100, con dos códigos de acceso, uno para administrador, y otro para el resto de los usuarios, además de algunos parámetros específicos del sistema MeetMe.

Para poder acceder a la misma, simplemente definimos en nuestro plan de marcación la parte correspondiente:

\begin{lstlisting}[style=bash,title={/etc/asterisk/extensions.conf}]
exten => 103,1,NoOp()
same => n,MeetMe(100)
same => n,Hangup()
\end{lstlisting}

Por otro lado vamos a configurar el sistema MeetMe en formato Realtime, para poder utilizarlo con una interfaz web especifica, llamada Web-Meetme \footnote{Instalación Web-Meetme en WIKIAsterisk, http://wikiasterisk.com/index.php?title=Web-MeetMe}.

Así que debemos crear una base de datos específica para este contexto, que llamaremos meetme:

\begin{lstlisting}[style=consola]
mysqladmin -u root -p create meetme
\end{lstlisting}

Y crearemos la estructura de tablas utilizando el siguiente script, extraído y adaptado, del fichero del paquete de instalación de Web-Meetme:

\lstinputlisting[title={./tablasmeetme.sql},style=sql]{../scripts/tablasmeetme.sql}

Y procedemos a insertarla dentro de nuestra base de datos ``asterisk'':

\begin{lstlisting}[style=consola]
mysql -u root -p meetme < tablasmeetme.sql
\end{lstlisting}

Añadimos un usuario administrador a la tabla ``user'' para nuestro cliente Don Pedro:

\begin{lstlisting}[style=consola]
mysql -u root -p meetme -e "INSERT INTO meetme.user (first_name, last_name, 
email, telephone, password, admin) VALUES ('Pedro', 'de los Palotes', 
'ppalotes@wikiasterisk.com', '956001154', 'asterisk', 'Admin');"
\end{lstlisting}

Y también permitir en la base de datos \textbf{meetme} acceso total al usuario asterisk:

\begin{lstlisting}[style=consola]
mysql -u root -p meetme -e "mysql -u root -p -e 
"GRANT ALL PRIVILEGES ON meetme.* TO 'asterisk'@'localhost';"
\end{lstlisting}

Por otro lado añadimos la siguiente linea en el fichero \textbf{extconfig.php} donde se definen los módulos convertibles a Asterisk Realtime y las tablas que lo asocian en las bases de datos:

\begin{lstlisting}[style=bash,title={/etc/asterisk/extconfig.conf}]
meetme => odbc,meetme_odbc,booking
\end{lstlisting}

También tenemos que incorporar algunas modificaciones en nuestro fichero res\_odbc.conf para incorporar una nueva configuración, para que conecte al Driver ODBC con el DSN meetme, para la nueva base de datos con el mismo nombre:

\begin{lstlisting}[style=bash,title={/etc/asterisk/res\_odbc.conf}]

[meetme_odbc]
enabled => yes
dsn => meetme
username => asterisk
password => asterisk
pre-connect => yes

\end{lstlisting}

Ya por último, terminar de configurar el driver ODBC, y especificar el DSN específico meetme con el que se realizará toda la trasmisión de información entre MySQL y Asterisk:

\begin{lstlisting}[style=bash,title={/etc/odbc.ini}]

[meetme]
Description = MeetMe para MySQL
Driver = MySQL
Server = localhost
Database = meetme
Socket = /var/run/mysqld/mysqld.sock

\end{lstlisting}

Y ya culminando esta parte, solo queda la instalación propiamente dicha, del sistema Web-Meetme siguiendo los pasos de WikiAsterisk.com, considerar que modificaríamos el fichero manager.conf de la interfaz AMI para adaptarlo a la configuración especifica de esta interfaz añadiendo lo siguiente:

\begin{lstlisting}[style=bash,title={/etc/asterisk/manager.conf}]

[meetme]
secret = meetme 
read = call
write = command,originate
permit = 127.0.0.1/255.255.255.0

\end{lstlisting}

Una vez permitido el acceso al Manager con un usuario y contraseña especifico es necesario que recurramos a un fichero concreto, que ofrece la instalación de Web-Meetme. 

Considerando que Web-Meetme, incorpora una versión de PHP-AGI \footnote{Interfaz AGI, WIKIAsterisk, http://wikiasterisk.com/index.php?title=AGI}, solo necesitamos configurar el fichero phpagi.conf para dar la funcionalidad a la clase AGI\_AsteriskManager:

\lstinputlisting[title={/etc/asterisk/phpagi.conf},style=bash]{../conf/phpagi.conf}

Y tambien editar un fichero de configuración para la conexión a la base de datos de la aplicación MeetMe propia:

\begin{lstlisting}[style=php,title={/var/www/web-meetme/lib/database.php}]

include_once 'DB.php';
$database = 'meetme';
$host = 'localhost';
$username = 'asterisk';
$password = 'asterisk';

\end{lstlisting}

Finalmente vamos a especificar algunos parámetros concretos, para que nuestro sistema Web-MeetMe funcione con plenitud \footnote{Configuración Adicional Web-MeetMe, WikiAsterisk.com, \\ http://wikiasterisk.com/index.php?title=Web-MeetMe\#Configuraci.C3.B3n\_Adicional}.

\begin{lstlisting}[style=php,title={/var/www/web-meetme/lib/defines.php}]

define ("WEBROOT", "http://pfc-asterisk.local/web-meetme/");
define ("FSROOT", "/var/www/web-meetme/");
define ("LIBDIR", FSROOT."lib/");

define ("OUT_CONTEXT", "extensiones");
define ("OUT_CALL_CID", "Invitacion Meetme <102>");

define ("AUTH_TYPE", "sqldb");
define ("AUTH_TIMEOUT", "3");

define("LOCAL_SUPPORT", "Departmento de Soporte");
define("LOCAL_PHONE", "956001151");
define("PHONENUM", "956001171");

\end{lstlisting}

Con todo esto, ya quedaría el sistema Web-Meetme completamente configurado, podemos ver una imagen con distintas conferencias creadas dínamicamente en la interfaz, en la Figura \ref{meetme_conf}. Ya solo quedaría realizar un pequeño ajuste en el Plan de Marcación, para incluir un nuevo número DDI especifico para conectar a nuestro sistema de salas dinámicas:

\figura{meetme_conf.png}{scale=1}{Lista de Conferencias Dínamicas Web-MeetMe}{meetme_conf}{!ht}

\begin{lstlisting}[style=bash,title={/etc/asterisk/extensions.conf}]

exten => 102,1,NoOp()
same => n,MeetMe()
same => n,Hangup()

\end{lstlisting}

Con esto ya habríamos terminado todas las tareas que nos encomendó Pedro de los Palotes y podríamos proceder a la entrega según previsto.

\subsection{Comprobación: Conferencias Corporativas}

Por un lado tenemos el sistema MeetMe estático. Su comprobación es directa. Desde dos terminales accedemos a la extensión 103, marcamos la clave 1234 y deberíamos de estar en comunicación entre estos dos teléfonos de manera inmediata. 

Podemos agregar un tercero para comprobar que la conferencia es correcta aunque con dos realmente es suficiente.

En el caso del sistema Realtime, podríamos comprobar que funciona correctamente utilizando el comando CLI, vemos que aparece\textbf{ Connected: Yes}, simboliza que la conexión esta establecida. Desde la interfaz web podríamos crear una sala de conferencias, y llamando a la extensión 102, acceder a la misma, siguiendo las instrucciones de voz que nos va indicando el sistema.

\begin{lstlisting}[style=consola]

CLI> odbc show meetme_odbc

ODBC DSN Settings
-----------------

  Name:   meetme_odbc
  DSN:    meetme
    Last connection attempt: 1970-01-01 01:00:00
  Pooled: No
  Connected: Yes

\end{lstlisting}
